import os
import subprocess
import traceback
import re
import sys
import time
try:
    import color_print
except:
    from python import color_print

class typeset:
    def __init__(self, project_name: str):
        self.file_name = project_name
        # 色と共に出力できるクラスをインスタンス化
        self.Color = color_print.ColorPrint()
        # タイプセットするファイルの最大行数を取得
        self.max_lines = 0
        self.max_pages = 0
        try:
            with open(self.file_name + '.tex', mode='r', encoding="utf-8_sig") as tex_f:
                for _ in tex_f:
                    self.max_lines += 1
                self.max_lines += 1
        except:
            self.Color.printRed("ファイルが見つかりません")
            sys.exit()
        # 現在の処理番号を保持
        self.progress = 0
        # 進捗を計算するときに基とする計算結果を保持
        self.progress_base = 0.0
        # 今までで進んだ最大の進捗を保持
        self.progress_max = 0.0
        # 実際に行う処理内容を保持(表示用)
        self.task_list = ["platex " + self.file_name + ".tex"]
        # 処理ごとの達成度を割合で保持
        self.bar = [100]
        # reパッケージを使用して検索する正規表現をあらかじめコンパイルする
        # LaTeX Warning: などを検索
        self.latex_warning_start_pattern = re.compile('^LaTeX Warning:')
        # LaTeX Warning: を表示するパターン
        self.latex_warning_pattern = re.compile('^LaTeX Warning:(.*)on.*input.*line[ |]([0-9]+)\.')
        # OverfullやUnderfullのWarningの開始を判断するパターン
        self.overfull_underfull_start_pattern = re.compile('^(Overfull)|(Underfull)')
        # OverfullやUnderfullのWarningの終了を判断するパターン
        self.overfull_underfull_finish_pattern = re.compile('^(\[[0-9]+\])|(Excluding )')
        # エラー表示をするパターン
        self.error_pattern = re.compile('( \.\.\.)|(^\! )|\<inserted text\>')
        self.error_pattern2 = re.compile('\(Press Enter to retry, or Control-Z to exit\)')

    def displayProgress(self, pages=-1, lines=-1, finish_flag=False):
        now_progress = 0
        task = self.task_list[self.progress]
        if pages == -1 and lines == -1 and not finish_flag:
            self.Color.printRed("進捗表示のためのメソッドの引数が意図しないものになっている", str(pages), str(lines), str(finish_flag))
            return False
        if len(self.task_list) < self.progress:
            self.Color.printRed("進捗表示のためのメソッドの進捗が意図しないものになっている")
            return False
        # 処理が終了したとき
        if finish_flag:
            self.progress_base = sum(self.bar[:self.progress+1])
            self.progress_max = self.progress_base
        # エラーが出た行数で進捗を判断する
        elif pages == -1 or self.progress == 0:
            now_progress = self.progress_base + lines / self.max_lines * self.bar[self.progress]
            if not pages == -1:
                self.max_pages = pages
        # 処理している?ページ数で進捗を判断する
        else:
            # 最初のタイプセット時に参考文献が埋め込まれてない都合で最大ページを表示できないので、それの対策
            if pages > self.max_pages:
                self.max_pages = pages
            now_progress = self.progress_base + pages / self.max_pages * self.bar[self.progress]
        if now_progress > self.progress_max:
            self.progress_max = now_progress
        # 進捗の表示
        print(self.Color.green + ' {:5.1f}%'.format(self.progress_max) + self.Color.end, '[' + str(self.progress + 1) + '/' + str(len(self.task_list)) + ']', task, end='\r')
        # 処理が終了したとき
        if finish_flag:
            self.progress += 1
    def displayProgressClear(self):
        print(" " * (30 + len(self.file_name)), end='\r')
    
    def printDisplay(self, *string, end="\n", color=""):
        s = [str(i) for i in string]
        self.displayProgressClear()
        if color == "":
            print(' '.join(s), end=end)
        elif color == "red":
            self.Color.printRed(' '.join(s), end=end)
        elif color == "blue":
            self.Color.printBlue(' '.join(s), end=end)
        elif color == "green":
            self.Color.printGreen(' '.join(s), end=end)
        elif color == "yellow":
            self.Color.printYellow(' '.join(s), end=end)


    def removeAutoGeneratedFiles(self, extensions: list):
        return_list = []
        for extension in extensions:
            try:
                os.remove(self.file_name + extension)
            except:
                return_list.append(extension)
            time.sleep(0.1)
        if not return_list == []:
            print("以下の拡張子の自動生成ファイルの削除に失敗しました: " + ', '.join(return_list))
        return return_list

    def command(self, command: str):
        # シェルコマンドを非同期で実行
        if os.name == "nt":
            # Windowsの場合
            self.printDisplay("#" * (20 + len(self.file_name)) + "\n",command,"\n" + "#" * (20 + len(self.file_name)), color="blue")
            proc = subprocess.Popen(command, shell = True, stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.STDOUT)
        else:
            self.printDisplay("#" * (20 + len(self.file_name)) + "\nexec ",command,"\n" + "#" * (20 + len(self.file_name)), color="blue")
            proc = subprocess.Popen("exec " + command, shell = True, stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.STDOUT)
        return proc

    def latexTypeset(self, command: str, small_display=False):
        end_count = 0
        end_flag = False
        return_d = True
        try:
            proc = self.command(command)
            overfull_underfull_flag = False
            last_text = ""
            self.displayProgress(lines=0, finish_flag=False)
            while True:
                if not (end_count == 0 and end_flag):
                    line = proc.stdout.readline()
                else:
                    self.printDisplay("Error: platex " + self.file_name + ".tex", color="red")
                    self.displayProgress(lines=0, finish_flag=False)
                    proc.kill()
                    return_d = False
                    break
                if line:
                    line_str = line.decode('utf-8')
                    # エラーになっているかをチェック
                    m_error = self.error_pattern.search(line_str)
                    if not m_error is None:
                        # エラーがあると停止するため、エラーの所を表示してからシェルコマンドを停止させる
                        if not end_flag:
                            if '...' in m_error.group():
                                end_count = 4
                            else:
                                end_count = 3
                            end_flag = True
                    m_error = self.error_pattern2.search(line_str)
                    if not m_error is None:
                        end_count = 1
                        end_flag = True
                    if end_flag:
                        self.printDisplay(line_str.replace('\r', '').replace('\n', ''), color="red")
                    # Warningまたは通常
                    else:
                        now_lines = 0
                        now_pages = -1
                        word = last_text + line_str.replace('\r', '').replace('\n', '')
                        # LaTeX Warningを判断する
                        m_latex_warning = self.latex_warning_start_pattern.search(word)
                        if not m_latex_warning is None:
                            overfull_underfull_flag = False
                            m_latex_warning_complete = self.latex_warning_pattern.search(word)
                            if not m_latex_warning_complete is None:
                                if self.progress +1 == len(self.task_list) or not small_display:
                                    self.printDisplay('LaTeX Warning:' + m_latex_warning_complete.group(1) + 'on input line ' + m_latex_warning_complete.group(2) + '.', end="\n\n", color="yellow")
                                now_lines = int(m_latex_warning_complete.group(2))
                                last_text = ''
                            else:
                                last_text = word
                        elif overfull_underfull_flag:
                            m_overfull_underfull_complete = self.overfull_underfull_finish_pattern.search(word)
                            # [number]や改行をしていない場合は、OverfullやUnderfullのWarningメッセージが継続していると判断する
                            if m_overfull_underfull_complete is None and word != "":
                                # 4: platex, pbibtex, platex, platex ...と実行する時に四つ目以降の処理に反応するための数字
                                if self.progress + 1 >= 4 or not small_display:
                                    self.printDisplay("t",word, color="yellow")
                            else:
                                self.displayProgressClear()
                                # 4: platex, pbibtex, platex, platex ...と実行する時に四つ目以降の処理に反応するための数字
                                if self.progress + 1 >= 4 or not small_display:
                                    print("") # 改行するため
                                overfull_underfull_flag = False
                        else:
                            # OverfullやUnderfullのWarningを判断する
                            m_overfull_underfull = self.overfull_underfull_start_pattern.search(word)
                            if not m_overfull_underfull is None:
                                overfull_underfull_flag = True
                                # 4: platex, pbibtex, platex, platex ...と実行する時に四つ目以降の処理に反応するための数字
                                if self.progress + 1 >= 4 or not small_display:
                                    self.printDisplay(word, color="yellow")
                            elif not small_display:
                                self.printDisplay(word)
                        # 処理をしている?ページ数を判断する
                        display_pages_list = re.findall('\[[0-9]+\]', word)
                        if not display_pages_list == []:
                            now_pages_str = display_pages_list[-1]
                            now_pages = int(now_pages_str.replace('[', '').replace(']', ''))
                if end_count > 0:
                    end_count = end_count - 1
                self.displayProgress(pages=now_pages, lines=now_lines, finish_flag=False)
                if not line and proc.poll() is not None:
                    self.displayProgressClear()
                    self.displayProgress(finish_flag=True)
                    break
        except:
            traceback.print_exc()
            self.printDisplay("Error: platex " + self.file_name + ".tex", color="red")
            self.displayProgressClear()
            self.displayProgress(pages=now_pages, lines=now_lines, finish_flag=False)
            return_d = False
        return return_d

    def bibset(self, small_display=False):
        return_d = True
        try:
            # シェルコマンドを非同期で実行
            proc = self.command("pbibtex " + self.file_name)
            print_list = [] # small_display==Trueかつエラーがあった時に表示するようにする
            self.displayProgress(lines=0, finish_flag=False)
            while True:
                line = proc.stdout.readline()
                if line:
                    line_str = line.decode('utf-8')
                    m = re.search('Warning', line_str)
                    if not m is None:
                            # リファレンスがないWarningと表示されるものがあった時にFalseを返すようにする
                            self.displayProgressClear()
                            if small_display:
                                for s in print_list:
                                    print(s)
                                small_display = False
                            self.printDisplay(line_str.replace('\r', '').replace('\n', ''), color="yellow")
                    else:
                        m = re.search('error', line_str)
                        if not m is None:
                            # リファレンスがないWarningと表示されるものがあった時にFalseを返すようにする
                            return_d = False
                            self.displayProgressClear()
                            for s in print_list:
                                print(s)
                            small_display = False
                            self.printDisplay(line_str.replace('\r', '').replace('\n', ''), color="red")
                        elif not small_display:
                            self.printDisplay(line_str.replace('\r', '').replace('\n', ''))
                        else:
                            print_list.append(line_str.replace('\r', '').replace('\n', ''))
                        self.displayProgress(lines=0, finish_flag=False)
                if not line and proc.poll() is not None:
                    self.displayProgressClear()
                    self.displayProgress(lines=0, finish_flag=True)
                    break
        except:
            traceback.print_exc()
            self.printDisplay("Error: pbibtex " + self.file_name, color="red")
            self.displayProgressClear()
            self.displayProgress(lines=0, finish_flag=False)
            return_d = False
        return return_d
    
    def dvipdfmx(self, small_display=False):
        return_d = True
        now_pages = -1
        try:
            # シェルコマンドを非同期で実行
            proc = self.command("dvipdfmx " + self.file_name)
            print_list = [] # small_display==Trueかつエラーがあった時に表示するようにする
            self.displayProgress(lines=0, finish_flag=False)
            while True:
                line = proc.stdout.readline()
                if line:
                    line_str = line.decode('utf-8')
                    m = re.search('dvipdfmx:fatal', line_str)
                    if not m is None:
                        # 既にpdfを開いているので閉じる必要がある
                        return_d = False
                        self.printDisplay(line_str.replace('\r', '').replace('\n', ''), color="red")
                        m = re.search('Unable to open ', line_str)
                        if type(m) is None and m.span() != (0, 0):
                            self.printDisplay("pdfファイルを開いている可能性があります。閉じてください。", color="red")
                    elif not small_display:
                        self.printDisplay(line_str.replace('\r', '').replace('\n', ''))
                    else:
                        print_list.append(line_str.replace('\r', '').replace('\n', ''))
                    display_pages_list = re.findall('\[[0-9]+\]', line_str.replace('\r', '').replace('\r', ''))
                    if not display_pages_list == []:
                        now_pages_str = display_pages_list[-1]
                        now_pages = int(now_pages_str.replace('[', '').replace(']', ''))
                    self.displayProgress(lines=0, pages=now_pages, finish_flag=False)
                elif not line and proc.poll() is not None:
                    self.displayProgressClear()
                    self.displayProgress(lines=0, finish_flag=True)
                    break
        except:
            traceback.print_exc()
            self.printDisplay("Error: dvipdfmx " + self.file_name, color="red")
            self.displayProgressClear()
            self.displayProgress(lines=0, finish_flag=False)
            return_d = False
        return return_d

    def typeset(self, small_display=False):
        command = "platex " + self.file_name + ".tex"
        return self.latexTypeset(command, small_display)

    def tex2pdf(self, small_display=False):
        command = "ptex2pdf -l " + self.file_name
        return self.latexTypeset(command, small_display)

    def start_all(self, small_display=False, generate_pdf=False):
        remove_list = ['.aux', '.dvi', '.lof', '.log', '.toc', '.lot', '.bbl', '.blg']
        self.removeAutoGeneratedFiles(remove_list)
        if generate_pdf:
            self.task_list = ["platex "+self.file_name+".tex", "pbibset "+self.file_name,"platex "+self.file_name+".tex","platex "+self.file_name+".tex", "dvipdfmx "+self.file_name]
            self.bar = [28, 8, 28, 28, 8]
        else:
            self.task_list = ["platex "+self.file_name+".tex", "pbibset "+self.file_name,"platex "+self.file_name+".tex","platex "+self.file_name+".tex"]
            self.bar = [30, 10, 30, 30]
        if not self.typeset(small_display=small_display):
            return False
        if not self.bibset(small_display=small_display):
            return False
        for _ in range(2):
            if not self.typeset(small_display=small_display):
                return False
        if generate_pdf:
            if not self.dvipdfmx(small_display=small_display):
                return False
        print("") # 改行のため
        return True

if __name__ == '__main__':
    file_name = sys.argv[1]
    typesetC = typeset(file_name)
    simple = False
    if "--simple" in sys.argv:
        simple = True
    if "--tex2pdf" in sys.argv:
        typesetC.task_list=["ptex2pdf " + file_name + ".tex"]
        typesetC.tex2pdf(small_display=simple)
    else:
        typesetC.start_all(small_display=simple)
